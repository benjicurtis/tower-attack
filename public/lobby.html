<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tower Attack - Lobby</title>
  <link rel="stylesheet" href="lobby.css">
</head>
<body>
  <div id="lobby-container">
    <div class="lobby-header">
      <h1 class="game-title">üè∞ Tower Attack</h1>
      <p class="game-subtitle">Pick a name, pick a color, and join the experience.</p>
    </div>

    <!-- Isometric Rendering Content -->
    <div class="isometric-content-section">
      <h2>Understanding Isometric Graphic Rendering</h2>
      
      <p>Isometric projection represents a powerful technique in computer graphics for visualizing three-dimensional objects and environments on two-dimensional displays. Unlike perspective projection, which mimics how the human eye perceives depth with vanishing points, isometric projection maintains parallel lines and consistent scaling regardless of distance from the viewer. This approach creates a distinctive visual style that has proven invaluable across architectural visualization, technical illustration, simulation software, and interactive media.</p>
      
      <p>The mathematical foundation of isometric rendering relies on a specific transformation matrix that rotates the standard Cartesian coordinate system. In true isometric projection, the three axes (x, y, and z) are equally foreshortened and separated by 120-degree angles when projected onto the viewing plane. The transformation typically involves rotating the coordinate system 45 degrees around the vertical axis, followed by approximately 35.264 degrees (arctan(1/‚àö2)) around the horizontal axis. This produces the characteristic diamond-shaped grid where vertical lines remain vertical, while the x and z axes project at 30 degrees from horizontal.</p>
      
      <p>Implementing isometric graphics requires careful consideration of coordinate transformation. A point in 3D space (x, y, z) is mapped to screen coordinates using the transformation equations: screen_x = (x - z) √ó cos(30¬∞) and screen_y = (x + z) √ó sin(30¬∞) - y. These calculations must account for the scale factor, typically multiplied by the desired tile or grid size in pixels. The y-coordinate, representing height or elevation, directly affects the vertical screen position, allowing for natural representation of stacked objects and terrain elevation.</p>
      
      <p>Depth sorting presents one of the primary technical challenges in isometric rendering systems. Since objects farther from the viewer must be drawn before closer objects to achieve proper occlusion, rendering engines must implement sophisticated sorting algorithms. The painter's algorithm, which sorts objects by their depth coordinates before rendering, provides a foundational approach. However, complex scenes with overlapping objects require more advanced techniques such as binary space partitioning (BSP) trees or scanline algorithms that can handle cases where simple depth sorting fails.</p>
      
      <p>Modern rendering frameworks provide robust support for isometric graphics through specialized libraries and engines. Phaser, a popular 2D framework, includes built-in isometric plugins that handle coordinate transformation and rendering order automatically. The PixiJS library offers flexible sprite rendering with custom projection matrices, making it suitable for implementing custom isometric systems. Three.js, while primarily designed for 3D graphics, can be configured with an orthographic camera to achieve isometric projection, providing access to WebGL acceleration and advanced lighting effects.</p>
      
      <p>Tile-based isometric engines offer particular advantages for applications requiring structured environments. These systems organize content into a grid of tiles, where each tile corresponds to a discrete unit in the logical space. Libraries such as Tiled Map Editor provide visual tools for designing isometric layouts, which can then be loaded and rendered using compatible frameworks. This approach simplifies collision detection, pathfinding, and spatial queries by maintaining a clear relationship between screen coordinates and logical grid positions.</p>
      
      <p>Performance optimization in isometric rendering focuses on minimizing overdraw and efficiently managing scene complexity. Techniques such as frustum culling eliminate objects outside the visible area, while chunk-based loading systems divide large environments into manageable sections. Sprite atlasing reduces texture switching overhead by combining multiple graphical elements into single textures. For dynamic scenes with many moving objects, spatial indexing structures like quadtrees enable rapid queries to determine which objects need updating or rendering each frame.</p>
      
      <p>The mathematical precision of isometric projection extends beyond basic coordinate transformation to encompass lighting models, shadow calculation, and interaction handling. Ambient occlusion can be pre-calculated for static geometry to enhance depth perception, while dynamic shadows require ray-casting algorithms adapted to the isometric coordinate system. Input handling must convert screen-space mouse coordinates back to world-space positions through inverse transformation, enabling users to interact naturally with the rendered environment. These components combine to create cohesive isometric applications that balance visual clarity with technical performance.</p>
    </div>

    <!-- Player Info Section -->
    <div class="player-setup">
      <div class="player-name-section">
        <label for="player-name">Your Name:</label>
        <input type="text" id="player-name" placeholder="Enter your name..." maxlength="20">
      </div>
      <div class="player-color-section">
        <label>Choose Color:</label>
        <div class="hex-color-editor" aria-label="Custom hex color">
          <div class="hex-color-preview" id="hex-color-preview" title="Selected color"></div>
          <div class="hex-color-fields">
            <span class="hex-prefix">#</span>
            <div class="hex-byte">
              <span class="hex-byte-label">R</span>
              <input id="hex-r" type="text" inputmode="text" maxlength="2" placeholder="FF" autocomplete="off" autocapitalize="characters" spellcheck="false" aria-label="Red hex byte">
            </div>
            <div class="hex-byte">
              <span class="hex-byte-label">G</span>
              <input id="hex-g" type="text" inputmode="text" maxlength="2" placeholder="FF" autocomplete="off" autocapitalize="characters" spellcheck="false" aria-label="Green hex byte">
            </div>
            <div class="hex-byte">
              <span class="hex-byte-label">B</span>
              <input id="hex-b" type="text" inputmode="text" maxlength="2" placeholder="FF" autocomplete="off" autocapitalize="characters" spellcheck="false" aria-label="Blue hex byte">
            </div>
          </div>
          <div class="hex-color-help" id="hex-color-help">Enter hex bytes (00‚ÄìFF).</div>
        </div>
        <div class="color-picker" id="color-picker">
          <!-- Colors will be generated by JS -->
        </div>
      </div>
    </div>

    <!-- Simulation Mode Section -->
    <div class="game-modes-section">
      <h2>Simulation Mode</h2>
      <div class="game-modes-grid">
        
        <!-- Free Build Mode -->
        <div class="game-mode-card" data-mode="freeplay">
          <div class="mode-icon">üèóÔ∏è</div>
          <h3>Free Build</h3>
          <p>Build freely and explore. No NPCs.</p>
          <div class="mode-stats">
            <span class="player-count">0 participants</span>
            <span class="mode-tag tag-casual">Exploratory</span>
          </div>
        </div>

        <!-- Classic Stomp Mode -->
        <div class="game-mode-card" data-mode="classic-stomp">
          <div class="mode-icon">üëü</div>
          <h3>Classic Stomp</h3>
          <p>NPCs enabled. Stomp them from above!</p>
          <div class="mode-stats">
            <span class="player-count">0 participants</span>
            <span class="mode-tag tag-action">Interactive</span>
          </div>
        </div>

        <!-- King of the Hill Mode -->
        <div class="game-mode-card" data-mode="king-of-the-hill">
          <div class="mode-icon">üëë</div>
          <h3>King of the Hill</h3>
          <p>Hold the hill to earn points. Most points wins.</p>
          <div class="mode-stats">
            <span class="player-count">0 participants</span>
            <span class="mode-tag tag-competitive">Objective-Based</span>
          </div>
        </div>

        <!-- Infection Mode -->
        <div class="game-mode-card" data-mode="infection">
          <div class="mode-icon">ü¶†</div>
          <h3>Infection</h3>
          <p>One participant starts infected. Touch a carrier to spread it.</p>
          <div class="mode-stats">
            <span class="player-count">0 participants</span>
            <span class="mode-tag tag-infection">Infection</span>
          </div>
        </div>

      </div>
    </div>

    <!-- Active Rooms Section -->
    <div class="rooms-section">
      <h2>Active Sessions</h2>
      <div class="rooms-list" id="rooms-list">
        <div class="no-rooms">No active sessions. Create one to begin!</div>
      </div>
    </div>

    <!-- Selected Mode Info -->
    <div class="selected-mode-panel" id="selected-mode-panel" style="display: none;">
      <div class="selected-mode-content">
        <div class="selected-mode-text">
          <h3 id="selected-mode-title"></h3>
          <p id="selected-mode-description"></p>
        </div>

        <div class="selected-mode-controls" id="selected-mode-controls" style="display:none;">
          <div class="weapon-row" id="stomp-duration-row" style="display:none;">
            <label for="stomp-duration-select">Session length</label>
            <select id="stomp-duration-select">
              <option value="1">1 min</option>
              <option value="2">2 min</option>
              <option value="3" selected>3 min</option>
              <option value="4">4 min</option>
              <option value="5">5 min</option>
            </select>
          </div>

          <div class="weapon-row" id="koth-duration-row" style="display:none;">
            <label for="koth-duration-select">Session length</label>
            <select id="koth-duration-select">
              <option value="1">1 min</option>
              <option value="2">2 min</option>
              <option value="3" selected>3 min</option>
              <option value="4">4 min</option>
              <option value="5">5 min</option>
            </select>
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" id="create-room-btn">Create Session</button>
          <button class="btn btn-secondary" id="quick-join-btn">Quick Join</button>
          <button class="btn btn-cancel" id="cancel-btn">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Real-Time Collaborative Rendering Content -->
    <div class="isometric-content-section">
      <h2>Real-Time Collaborative Rendering and Network Synchronization</h2>
      
      <p>Real-time collaborative rendering systems enable multiple users to interact with shared virtual environments simultaneously, presenting unique technical challenges in synchronization, latency management, and state consistency. These systems form the backbone of collaborative design tools, architectural walkthroughs, training simulations, and multi-user visualization platforms. The architecture must balance responsiveness with accuracy, ensuring that each participant perceives a coherent shared state while minimizing the impact of network delays and bandwidth constraints.</p>
      
      <p>Client-server architectures dominate real-time collaborative rendering implementations due to their centralized authority model. The server maintains the authoritative state of the virtual environment, processing input from all connected clients and broadcasting state updates. This approach simplifies conflict resolution when multiple users attempt to modify the same objects or occupy the same space. However, the round-trip time between client input and server acknowledgment introduces perceptible latency. Client-side prediction techniques mitigate this by immediately applying local user inputs to the client's view while awaiting server confirmation, rolling back only if the server's authoritative state differs.</p>
      
      <p>State synchronization protocols must efficiently transmit updates across potentially limited network connections. Delta compression reduces bandwidth by transmitting only the differences between consecutive states rather than complete snapshots. Interpolation smooths the appearance of remote entities by estimating intermediate positions between received updates, while extrapolation predicts future positions based on velocity vectors. Dead reckoning algorithms extend extrapolation by maintaining simplified physics models on each client, allowing entities to continue moving predictably even during temporary network disruptions.</p>
      
      <p>The entity-component-system (ECS) architecture pattern provides an effective organizational structure for collaborative rendering applications. Entities represent objects in the virtual environment, components store their attributes (position, appearance, physics properties), and systems process specific aspects of behavior (rendering, collision, networking). This separation enables selective synchronization where only components that frequently change, such as transform components, are transmitted over the network, while static components like mesh data are loaded once during initialization.</p>
      
      <p>WebSocket protocols and WebRTC data channels facilitate low-latency bidirectional communication between browsers and servers or between peer clients. WebSockets provide a reliable, ordered stream suitable for critical state updates and command transmission. WebRTC data channels offer both reliable and unreliable transport modes, where unreliable channels sacrifice guaranteed delivery for reduced latency, appropriate for frequently updated position data where newer information supersedes older packets. Modern implementations often employ hybrid approaches, using reliable channels for important events while streaming position updates over unreliable channels.</p>
      
      <p>Optimistic concurrency control allows clients to modify shared state immediately without waiting for server permission, improving perceived responsiveness. When conflicts arise‚Äîsuch as two users attempting to place objects in the same location‚Äîthe server resolves them according to predetermined rules, typically favoring the first modification received. Operational transformation algorithms enable sophisticated conflict resolution for collaborative editing scenarios, transforming concurrent operations to ensure consistency regardless of the order in which they are received and applied across different clients.</p>
      
      <p>Interest management techniques optimize bandwidth and processing resources by limiting the information each client receives to relevant portions of the environment. Spatial partitioning divides the virtual world into regions, with clients subscribing only to updates from their current region and immediate neighbors. Area-of-interest filtering further refines this by considering view frustums, object importance, and user attention, transmitting detailed updates for nearby, visible objects while providing reduced-frequency updates for distant or occluded entities.</p>
      
      <p>Scalability considerations drive architectural decisions in systems supporting large numbers of concurrent users. Horizontal scaling distributes load across multiple server instances, with each instance managing a subset of the virtual environment or a group of clients. Load balancers direct incoming connections to appropriate servers based on current capacity and geographic proximity. Distributed state management through shared databases or message queues enables servers to coordinate when users transition between regions managed by different instances. Performance monitoring systems track metrics such as tick rate, packet loss, and round-trip time, providing operational insight essential for maintaining quality of experience across diverse network conditions.</p>
    </div>
  </div>

  <script src="config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabaseClient.js"></script>
  <script src="lobby.js"></script>
</body>
</html>
